""" Reads data generated by KSHELL

    Provides a common memory format for handling different versions of
    KSHELL results
# TODO: Some segfaults might occur for very large files.
        Write an io-generator to pass to imap?
"""
import re
import pandas as pd
from multiprocessing import Pool


def resplit(line):
    line = line.rstrip().strip()
    pattern = re.compile(r'\s+(?![^()]*\))')
    return re.split(pattern, line)


def split(line: str) -> [str]:
    """ Split a KSHELL transition line into its constituents

    Does the same as resplit() but a bit faster and with uglier syntax

    >>> split("1-(17)  5.857    0-( 1)  4.870  0.987    0.000( 0.00)    0.001( 0.00)")
    ['1-', '17', '5.857', '0-', '1', '4.870', '0.987', '0.000', '0.00', '0.001', '0.00']
    """
    tokens = []
    in_paren = False
    word = ''
    for char in line:
        if char == ' ' and not in_paren and word:
            tokens.append(word)
            word = ''
        elif char in {'-', '+'} and word:
            tokens.append(word)
            tokens.append(char)
            word = ''
        elif char == '(':
            in_paren = True
            if word:
                tokens.append(word)
            word = ''
        elif char == ')':
            in_paren = False
            if word:
                tokens.append(word)
            word = ''
        else:
            if char != ' ':
                word += char

    if word and word != '\n':
        tokens.append(word)

    return tokens


def parse_tokens(tokens: [str]) -> [str]:
    """ Extract the interesting elements and convert them to correct type """
    Ji = int(tokens[0])
    Jf = int(tokens[4])
    pi_i = 1 if tokens[1] == '+' else -1
    Ei = float(tokens[3])
    pi_f = 1 if tokens[5] == '+' else -1
    Ef = float(tokens[7])
    dE = float(tokens[8])
    BM1if = float(tokens[9])
    if len(tokens) == 13:
        # Newer version
        Ji *= 2
        Jf *= 2
        pass
    elif len(tokens) == 11:
        # Older
        pass
    else:
        raise RuntimeError(f"Could not parse transitions. Unrecognized length {len(tokens)}, {tokens}")
    return [Ji, pi_i, Ei, Jf, pi_f, Ef, dE, BM1if]


def read_energy_levels(inputfile: str):
    """ Read levels from KSHELL summary file """
    levels = []
    stream = open(inputfile)
    old = False
    while True:
        tokens = stream.readline().strip().rstrip().split()
        if len(tokens) < 8:
            if len(levels):
                break     # Has read the entire block
            else:
                continue  # Block has yet to begin

        try:
            levels.append([int(tokens[1]),
                           1 if tokens[2] == '+' else -1,
                           float(tokens[5]),
                           float(tokens[6])])
        except ValueError:  # Skips header row
            if '2J' in tokens:
                old = True
            continue
    stream.close()

    df = pd.DataFrame(levels, columns=["J", "Parity", "E", "Ex"])
    if old:
        df['J'] *= 2

    # Combine J and Parity columns to allow for quick selection on (J, Pi)
    df['JPi'] = list(zip(df.J, df.Parity))
    return df


def read_ground_level_energy(inputfile: str) -> float:
    stream = open(inputfile)
    i = 0
    while True:
        tokens = stream.readline().strip().rstrip().split()
        try:
            Egs = float(tokens[5])
            return Egs
        except IndexError:
            continue
        except ValueError:
            continue
        if i > 10:
            raise RuntimeError("Could not find ground level energy")
        i += 1


def _parse_n_split(line: str) -> [str]:
    return parse_tokens(split(line))


def read_transition_strength(summary_file, transition_type='M1'):
    """

    Format of the pandas dataframe is:
    Ji: Initial spin, on the form 2J
    pi_i: Initial parity, +-1
    Ei: Energy of the transition relative to the ground
    Jf, pi_f, Ef: Same but for final
    dE: Difference between Ef and Ei
    BM1if: The B(M1) value from i to f
    """
    stream = open(summary_file)
    line = stream.readline()
    while line:
        line = stream.readline()
        if not line:
            raise RuntimeError(f"Could not find B({transition_type})")

        if line.startswith(f"B({transition_type})"):
            break

    # Parse the B(M1). The file format depends on the KSHELL version
    # Handle at least two versions
    line = stream.readline()
    line = stream.readline()
    if "J_i" in line:
        line = stream.readline()

    lines = []
    while len(line) > 1:
        lines.append(line)
        line = stream.readline()
    stream.close()

    pool = Pool()
    transitions = pool.map(_parse_n_split, lines)

    df = pd.DataFrame(transitions, columns=['Ji', 'pi_i', 'Ei',
                                            'Jf', 'pi_f', 'Ef',
                                            'dE', 'BM1'])
    # Older versions of KSHELL give the energy of the transitions in
    # absolute values, but to keep the format consistent,
    # these are transformed to relative to the ground level.
    if df['Ei'].iloc[0] < 0:
        Egs = read_ground_level_energy(summary_file)
        df['Ei'] = df['Ei'] - Egs
        df['Ef'] = df['Ef'] - Egs

    # Combine J and Parity columns to allow for quick selection on (J, Pi)
    df['JiPi'] = list(zip(df.Ji, df.pi_i))
    df['JfPi'] = list(zip(df.Jf, df.pi_f))

    return df
